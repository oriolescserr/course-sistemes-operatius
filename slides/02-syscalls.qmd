---
title: "Crides a sistema"
subtitle: "Unitat 2 ¬∑ Sistemes Operatius (SO)"
author: "Jordi Mateo Forn√©s"
logo: "/figures/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    footer: "Unitat 2 ¬∑ Sistemes Operatius (SO) [üè†](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---

## Que s√≥n les crides a sistema? {.smaller}


Les **crides a sistema**  s√≥n interf√≠cies que permeten a un programa en mode usuari sol¬∑licitar serveis al nucli del sistema operatiu de manera segura i controlada.


| Sistema operatiu | N¬∫ aproximat de syscalls | Notes                                            |
| ---------------- | ------------------------ | ------------------------------------------------ |
| Linux x86\_64    | \~300                    | Variaci√≥ segons kernel                           |
| FreeBSD          | \~500                    | Inclou syscalls BSD hist√≤rics                    |
| Windows NT       | \~2000                   | Crides natives `Nt*`; moltes encapsulades en DLL |


Normalment s‚Äôaccedeix a les *syscalls* a trav√©s de llibreries de sistema, que encapsulen i abstrauen les crides:

- **Unix/Linux**: *libc* (stdio.h, stdlib.h, sys/types.h, sys/shm.h, ‚Ä¶)
- **Windows**: API de Windows (kernel32.dll, ntdll.dll, ‚Ä¶)

## Principals crides a sistema? (I) {.smaller}

| Categoria                             |                Windows (API / Syscall)                |    Unix/Linux (Syscall)   | Descripci√≥                                                             |
| ------------------------------------- | :---------------------------------------------------: | :-----------------------: | ------------------------------------------------------------------------------- |
| **Control de processos**              |         `CreateProcess()` / `NtCreateProcess`         |    `fork()` / `clone()`   | `fork()` crea un proc√©s fill; Windows encapsula la syscall amb `CreateProcess`. |
|                                       |         `ExitProcess()` / `NtTerminateProcess`        |          `exit()`         | Tanca el proc√©s.                                                                |
|                                       |   `WaitForSingleObject()` / `NtWaitForSingleObject`   |   `wait()` / `waitpid()`  | Sincronitzaci√≥ de processos. |

## Principals crides a sistema? (II) {.smaller}

| Categoria                             |                Windows (API / Syscall)                |    Unix/Linux (Syscall)   | Descripci√≥                                                             |
| ------------------------------------- | :---------------------------------------------------: | :-----------------------: | ------------------------------------------------------------------------------- |                                 
| **Informaci√≥ i temporitzaci√≥**        | `GetCurrentProcessId()` / `NtQueryInformationProcess` |         `getpid()`        | Retorna PID.                                                                    |
|                                       |              `SetTimer()` / `NtSetTimer`              | `alarm()` / `nanosleep()` | Temporitzaci√≥ i delays.                                                         |
|                                       |             `Sleep()` / `NtDelayExecution`            | `sleep()` / `nanosleep()` | Pausa el proc√©s; variants m√©s precises disponibles.                             |
| **Comunicaci√≥ entre processos (IPC)** |        `CreatePipe()` / `NtCreateNamedPipeFile`       | `pipe()`  | Pipes an√≤nims; Windows tamb√© t√© Named Pipes, mailslots, shared memory.          |

## Principals crides a sistema? {.smaller}

| Categoria                             |                Windows (API / Syscall)                |    Unix/Linux (Syscall)   | Descripci√≥                                                             |
| ------------------------------------- | :---------------------------------------------------: | :-----------------------: | ------------------------------------------------------------------------------- |
| **Protecci√≥ i permisos**              |      `SetFileSecurity()` / `NtSetSecurityObject`      |    `chmod()`, `chown()`   | Windows usa ACLs complexes; Unix usa permisos Unix tradicionals.                |
| **Manipulaci√≥ de fitxers**            |            `CreateFile()` / `NtCreateFile`            |          `open()`         | Obre un fitxer.                                                                 |
|                                       |              `ReadFile()` / `NtReadFile`              |          `read()`         | Llegeix dades.                                                                  |
|                                       |             `WriteFile()` / `NtWriteFile`             |         `write()`         | Escriu dades.                                                                   |
|                                       |              `CloseHandle()` / `NtClose`              |         `close()`         | Tanca descriptor o handle.                                                      |
|                                       |            `DeleteFile()` / `NtDeleteFile`            |        `unlink()`         | Esborra un fitxer.                                                              |



## Exemple amb la llibreria (*stdio.h*)

:::center-container
![](../figures/slides/02-syscalls/printf-write.png){width="90%"}
:::

## Protecci√≥ de la CPU  {.smaller}

::: columns
::: {.column width="60%"}
- La CPU permet m√∫ltiples nivells de *seguretat*, anomenats **rings** (o anells).
- Cada **ring** (comen√ßant pel ring 0) restringeix l'acc√©s a certes instruccions.
- El kernel utilitza el ring 0 (anell de *fes el que vulguis*) com a **Kernel Space** i el ring 3 (l'anell on tens m√©s limitacions) com a **UserSpace** (on s'executen els teus programes).
:::
::: {.column width="40%"}
![](../figures/slides/02-syscalls/theory/rings.png)
:::
:::

::: {.fragment}
Degut a l'acc√©s restringit a la mem√≤ria i als ports d'E/S en el Ring 3, l'espai d'usuari no pot fer gaireb√© res per al m√≥n exterior sense cridar al kernel. No pot obrir fitxers, enviar paquets de xarxa, imprimir a la pantalla o assignar mem√≤ria.
:::


## Qu√® √©s una crida al sistema? (II) {.smaller}

1. Els programes en mode usuari necessiten accedir a recursos gestionats pel kernel (fitxers, dispositius, mem√≤ria, etc.).
2. El kernel s'executa en mode privilegiat (anell 0) amb acc√©s complet al maquinari.
3. Els programes en mode usuari s'executen en mode restringit (anell 3) amb acc√©s limitat.
4. Les crides al sistema s√≥n la interf√≠cie que permet als programes en mode usuari sol¬∑licitar serveis al kernel de manera segura.
5. No tenim cap instrucci√≥ que permeti canviar directament del mode usuari al mode kernel.

::: {.fragment .center-container}
### Com pot un proc√©s en mode usuari notificar al kernel que necessita fer alguna cosa? *Si no tenim cap instrucci√≥ que ho permeti?*
:::


## Com funciona el procesador? {.smaller}

El processador executa instruccions seguint el cicle:

::: center-container 
[How Do CPUs Run Programs Using the Fetch, Decode, Execute Cycle?](https://www.youtube.com/watch?v=ctjnYgCo8Bc)
<br>
Fetch ‚Üí Decode ‚Üí Execute ‚Üí Memory ‚Üí Writeback.
:::

Pot processar m√∫ltiples instruccions en paral¬∑lel gr√†cies a **pipelining** i execuci√≥ fora d‚Äôordre.

- El codi usuari no pot accedir directament a dispositius o mem√≤ria reservada.
- Els dispositius envien interrupcions per indicar esdeveniments (ex.: teclat, disc, xarxa).
- El kernel intercepta aquestes interrupcions i pot invocar handlers, que poden traduir-se en crides a sistema per als processos usuari.

## Qu√® √©s una interrupci√≥? {.smaller}

Les interrupcions s√≥n senyals as√≠ncrons enviats al processador per indicar esdeveniments que requereixen atenci√≥ immediata. Poden ser de **hardware** (*teclat, disc, temporitzador*) o de **software** (*excepcions, traps, syscalls*).

### Gesti√≥ d‚Äôuna interrupci√≥

1. Guardar el context del proc√©s actual (registres, PC, flags).
2. Canviar a mode kernel.
3. Determinar la causa de la interrupci√≥ (vector d‚Äôinterrupcions).
4. Saltar a la Interrupt Service Routine (**RTI/ISR**).
5. Executar **ISR** per atendre l‚Äôesdeveniment.
6.Restaurar el context del proc√©s.
7. Tornar a mode usuari.

::: {.fragment .center-container}
Les interrupcions s√≥n priorit√†ries i poden executar-se **sobre** processos en execuci√≥ per garantir resposta immediata.
:::

## Qu√® √©s la taula d‚Äôinterrupcions? {.smaller}

- Quan el processador rep una interrupci√≥, ha de saber a quin codi saltar per atendre-la.
- La Interrupt Descriptor Table (**IDT**) √©s una estructura del kernel que indica al CPU la adre√ßa de cada **ISR**.
- Sense configurar la **IDT**, el CPU no sabria quin codi executar en rebre una interrupci√≥.

#### Qui configura la IDT?

- El kernel, a l‚Äôinici, inicialitza la **IDT** i apunta cada entrada a la seva **ISR** corresponent.
- El kernel tamb√© gestiona les actualitzacions de la **IDT** en temps d'execuci√≥, si √©s necessari.

:::{.callout-tip title="IDT"}
La IDT es pot veure directament al codi font del kernel Linux: [IDT](https://elixir.bootlin.com/linux/v6.11/source/arch/x86/include/asm/irq_vectors.h#L14) i on s'inicialitza: [IDT init](https://elixir.bootlin.com/linux/v6.16.4/source/arch/x86/kernel/idt.c#L194).
:::


## Excepcions {.smaller}

Les excepcions s√≥n *esdeveniments generats pel CPU* quan una **instrucci√≥ provoca una condici√≥ anormal**.
El sistema operatiu pot tractar l‚Äôexcepci√≥; si no pot, envia un senyal al proc√©s, que pot usar el gestor per defecte o un gestor espec√≠fic.

| Tipus     | Quan s‚Äôinforma        | Exemple                          | Descripci√≥                                                                     |
| --------- | --------------------- | -------------------------------- | ----------------------------------------------------------------------------- |
| **Fault** | Abans de l‚Äôexecuci√≥   | Page fault                       | Normalment es pot corregir; instrucci√≥ reintenta despr√©s del tractament.      |
| **Trap**  | Despr√©s de l‚Äôexecuci√≥ | Breakpoint, syscall              | Condici√≥ detectada despr√©s; sovint informativa o de depuraci√≥.                |
| **Abort** | Irrecuperable         | Paritat de mem√≤ria, kernel panic | No es pot continuar; sovint provoca terminaci√≥ del proc√©s o panic del kernel. |


## Exemples d'excepcions {.smaller}

| Name                   | Type      | Descripci√≥ curta                                        |
| ---------------------- | --------- | ------------------------------------------------------- |
| Divide-by-zero         | Fault     | Instrucci√≥ divideix per zero                            |
| Debug                  | Trap      | Depuraci√≥; despr√©s de la instrucci√≥                     |
| Non-maskable Interrupt | Interrupt | Interrupci√≥ cr√≠tica de hardware                         |
| Breakpoint             | Trap      | Trap de depuraci√≥ per breakpoint                        |
| Overflow               | Trap      | L‚Äôoperaci√≥ aritm√®tica sobrepassa capacitat del registre |
| Bound Range Exceeded   | Fault     | Index fora de rang en instrucci√≥ BOUND                  |
| Device not Available   | Fault     | FPU o dispositiu no disponible                          |
| Double Fault           | Abort     | Error cr√≠tic del CPU durant gesti√≥ d‚Äôuna altra excepci√≥ |
| Page Fault             | Fault     | Acc√©s a p√†gina no resident en mem√≤ria                   |

::: center-container
[Excepcions](https://wiki.osdev.org/Exceptions)
:::

::: notes
Per a m√©s informaci√≥ podeu consultar el seg√ºent enlla√ß: [Excepcions](https://wiki.osdev.org/Exceptions).
:::


## Com accedim al Kernel {.smaller}

:::center-container
![](../figures/slides/02-syscalls/theory/excepciointerrupcio.png){width=60%}
:::

:::center
Un **trap** √©s una interrupci√≥ de software generada deliberadament pel proc√©s usuari per sol¬∑licitar un servei del kernel. La majoria de syscalls s'implementen com traps, que canvien a mode kernel i executen la funci√≥ corresponent.
:::

## `read(fd, buffer, nbytes)` 

#### Espai d'usuari

1. Programa C:
   * Posa *fd, buffer, nbytes* als registres(*RDI,RSI,RDX*).
   * Crida a `read()`.

2. Llibreria de sistema:
   * Posa el codi de `read` a *RAX*.
   * Executa **syscall** (TRAP a mode kernel).
  
::: {.fragment .center-container}
**Transici√≥ a mode kernel**
::: 


## `read(fd, buffer, nbytes)` 

* CPU canvia a mode supervisor i salta a la rutina del kernel indicada a la IDT.

::: {.fragment}
#### Espai del kernel

- Validaci√≥ de descriptors i permisos.
- Localitza rutina de tractament de `read` a la taula de syscall.
- Executa la rutina:
  - Llegeix dades del dispositiu d‚ÄôE/S.
  - Copia dades al buffer d‚Äôusuari (`copy_to_user`).
  - Retorna resultat (nombre de bytes llegits o -1 en cas d‚Äôerror).
:::



## `read(fd, buffer, nbytes)`

::: {.fragment .center-container}
**Transici√≥ a mode usuari**
::: 

- CPU restaura context del proc√©s i retorna al programa.

#### Espai d'usuari

* **Llibreria de sistema**: Retorna el resultat de la crida a `read()` al Programa C.
* **Programa**: Continua l'execuci√≥ utilitzant les dades llegides. O b√©, tracta l'error si n'hi ha (*errno*)

## Resum amb `open()` {.smaller}

:::center-container
![](../figures/slides/02-syscalls/theory/example_syscall.open.png){width=40%}
:::

```asm
# Executem a user space
mov edx,4       ; message length
mov ecx,msg     ; message to write
mov ebx,1       ; file descriptor (stdout)
mov eax,4       ; system call number (sys_write)
int 0x80        ; interrupt! Number 128 (0x80 in hex); 
```


## Setup de les crides a sistema {.smaller}

- Les syscalls estan identificades per n√∫meros √∫nics (syscall numbers).
- Arguments m√†xims: 6 registres, depenent de l‚Äôarquitectura.
- Valor de retorn: en el registre principal (EAX/RAX).

:::{.fragment .center-container}  
| Arquitectura | Registre syscall number | Arguments (1..6)               | Retorn |
| ------------ | ----------------------- | ------------------------------ | ------ |
| x86 32-bit   | `EAX`                   | `EBX, ECX, EDX, ESI, EDI, EBP` | `EAX`  |
| x86 64-bit   | `RAX`                   | `RDI, RSI, RDX, R10, R8, R9`   | `RAX`  |
:::

1. Programa usuari escriu arguments als registres corresponents.
2. Executa instrucci√≥ `int $0x80 (32-bit)` o `syscall (64-bit)` ‚Üí *trap al kernel*.
3. Kernel llegeix registre **syscall number**, localitza la rutina a la **syscall table**, executa i retorna resultat en **EAX/RAX**.

## Linux Syscall Dispatcher (I) {.smaller}


```c
__visible noinstr bool do_syscall_64(struct pt_regs *regs, int nr)
{
	nr = syscall_enter_from_user_mode(regs, nr); 
	if (!do_syscall_x64(regs, nr) && !do_syscall_x32(regs, nr) && nr != -1) {
		regs->ax = __x64_sys_ni_syscall(regs);
	}
	syscall_exit_to_user_mode(regs);
	return true;
}
```

- `syscall_enter_from_user_mode(regs, nr)`
  - Canvia a mode kernel.
  - Realitza validacions de seguretat i prepara els registres (RAX, RDI, RSI, etc.).

- `do_syscall_x64` / `do_syscall_x32`
  - Invoca la rutina correcta de la syscall table segons arquitectura.

- `syscall_exit_to_user_mode(regs)`
  - Prepara els registres per tornar a mode usuari.


::: center-container
[syscall_64.c](https://elixir.bootlin.com/linux/v6.16.4/source/arch/x86/entry/syscall_64.c#L94)
:::

## Linux Syscall Dispatcher (II) {.smaller}

```c
static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)
{
	unsigned int unr = nr;
	if (likely(unr < NR_syscalls)) {
		unr = array_index_nospec(unr, NR_syscalls);
		regs->ax = x64_sys_call(regs, unr);
		return true;
	}
	return false;
}
```

- `NR_syscalls`: nombre total de syscalls suportades.
- `array_index_nospec`: prevenci√≥ d‚Äôatacs de canal lateral al indexar la taula de syscalls.
- `x64_sys_call(regs, unr)`: crida la funci√≥ de syscall corresponent.
- Retorna `true` si la syscall √©s v√†lida i s‚Äôha executat, `false` en cas contrari.

::: center-container
[x64_syscall.c](https://elixir.bootlin.com/linux/v6.16.4/source/arch/x86/entry/syscall_64.c#L47)
:::

## Punters i seguretat {.smaller}

:::center-container
Tots els punters que provenen de l‚Äôusuari han de ser validads abans de ser utilitzats pel kernel.
:::

| Tipus de punter                        | Conseq√º√®ncia / tractament                   |
| -------------------------------------- | ------------------------------------------- |
| Punter a **kernel space** des d‚Äôusuari | Corrupci√≥ de dades del kernel ‚Üí bug cr√≠tic. |
| Punter **inv√†lid** a user space        | Page fault; el kernel gestiona l‚Äôerror.     |
| Punter **inv√†lid** dins del kernel     | Bug del kernel; pot provocar panic.         |


- Funcions com `__chk_user_ptr(ptr)` comproven si el punter apunta a espai usuari v√†lid.
- Si es fa servir un punter inv√†lid, la MMU genera un page fault que el kernel pot gestionar.
- Taula d‚Äôexcepcions: el kernel registra quines instruccions poden accedir a l‚Äôespai usuari.
- Permet diferenciar faults leg√≠tims de punters inv√†lids o errors del kernel.
- `__get_user()` i `__put_user()` s√≥n funcions que permeten llegir i escriure dades a l'espai d'usuari de manera segura.
- `__copy_to_user()` i `__copy_from_user()` s√≥n funcions que permeten copiar dades entre l'espai d'usuari i el kernel de manera segura.




## Acc√©s a dades d'usuari

::: columns
::: {.column width="50%"}

```c
#define get_user(x, ptr)					\
({								\
	const void __user *__p = (ptr);				\
	might_fault();						\
	access_ok(__p, sizeof(*ptr)) ?		\
		__get_user((x), (__typeof__(*(ptr)) __user *)__p) :\
		((x) = (__typeof__(*(ptr)))0,-EFAULT);		\
})
```
:::
::: {.column width="50%"}

1. `__chk_user_ptr(ptr)`: Valida que ptr apunta a espai usuari v√†lid abans d‚Äôaccedir-hi.
2. `might_fault()`: Marca que el codi seg√ºent pot generar un page fault.
3. `access_ok(__p, sizeof(*ptr))`: Comprova que l‚Äô√†rea de mem√≤ria √©s accessible.
4. `__get_user((x), (__typeof__(*(ptr)) __user *)__p)`: Llegeix el valor de l‚Äôadre√ßa d‚Äôusuari i el guarda a x.
5. Si l‚Äôacc√©s no √©s v√†lid, assigna 0 a x i retorna -EFAULT.

:::
:::

::: center-container
Protegeix el kernel de punters maliciosos o inv√†lids. Pots veure m√©s a [get_user](https://elixir.bootlin.com/linux/v6.16.4/source/include/asm-generic/uaccess.h#L50).
:::


## Virtual Dynamic Shared Object (VDSO) {.smaller}

√Ärea especial de mem√≤ria mapejada a l‚Äôespai usuari amb codi generat pel kernel per executar certes funcions de sistema de manera m√©s r√†pida. 

#### Objectiu
Evitar la transici√≥ completa a mode kernel, reduint lat√®ncia i cost de syscalls repetitives.

::: {.fragment .callout-tip title="Exemples"}
- `gettimeofday()`
- `time()`
- `getpid()`
:::

- Algunes dades din√†miques es troben en una regi√≥ de mem√≤ria RW dins del VDSO.
- La funci√≥ accedeix directament a aquestes dades sense fer una syscall completa.
- Si √©s necessari, el kernel actualitza aquestes dades de forma transparent.


# Resum de la dualitat {.smaller}

## Com funciona la dualitat?

:::center-container
![](../figures/slides/02-syscalls/theory/dualitat_so.png)
:::

## Canvi de context (I) 

:::center-container
![](../figures/slides/02-syscalls/theory/canvi_context_1.png){width=60%}
:::

## Canvi de context (II)

:::center-container
![](../figures/slides/02-syscalls/theory/canvi_context_2.png){width=60%}
:::

## Caracter√≠stiques de la dualitat {.smaller}

- Tot el codi del nucli s‚Äôexecuta amb tots els privilegis.
- Permet acc√©s complet a instruccions privilegiades i dispositius.
- El sistema operatiu limita el temps i el codi executat en mode supervisor per reduir riscos i lat√®ncia.
- Per accedir a serveis del nucli (syscalls, traps) cal un canvi de context:
  - Des del mode usuari ‚Üí mode kernel ‚Üí execuci√≥ ‚Üí retorn.
- Mecanisme controlat per accedir a rutines del kernel sense comprometre seguretat.
- Accions potencialment insegures (acc√©s a taules de p√†gines, E/S, control del CPU) prohibit en mode usuari.
- El kernel evita que processos accedeixin fora de la seva regi√≥ assignada.
- Transforma adreces l√≤giques (abstractes) en f√≠siques de forma segura.
- Interrupcions peri√≤diques i control del temporitzador
- El kernel pot interrompre processos usuari en qualsevol moment.

## Exemples d'instruccions privilegiades {.smaller}

* Assignaci√≥ d'adreces de mem√≤ria.
* Esborreu o invalideu la mem√≤ria cau de dades.
* Invalideu les entrades a les taules de p√†gines.
* Carregueu i llegiu els registres del sistema.
* Canvieu els modes de processador del nucli a l'usuari.
* Canvieu el voltatge i la freq√º√®ncia del processador.
* Parar un processador.
* Restableix un processador.
* Fer operacions d'E/S.

## Conclusi√≥ {.smaller}

- La CPU executa instruccions de manera **lineal**, una darrere l'altra.
- Per interactuar amb el m√≥n, dep√®n de les interrupcions.
- La CPU t√© diferents nivells de privilegi, anomenats **rings**, que ajuden el sistema operatiu a aplicar la seguretat i el control. 
- Els nostres programes normalment s'executen en l'anell menys privilegiat (mode usuari), cosa que significa que no podem executar directament certes instruccions.
- Ens comuniquem amb el nucli a trav√©s de crides al sistema (syscalls), que s√≥n essencialment un tipus d'interrupci√≥.
- El nucli tamb√© configura interrupcions pel seu compte per gestionar els processos (com pausar-ne un, canviar a un altre o gestionar diversos esdeveniments del sistema). Podeu [ampliar aqu√≠](https://0xax.gitbooks.io/linux-insides/content/Interrupts/linux-interrupts-9.html)



## Aix√≤ √©s tot per avui {.smaller}

::::: columns
::: {.column width="60%"}
#### TAKE HOME MESSAGE

-   Els monol√≠tics ofereixen velocitat per√≤ fragilitat.
-   Els microkernels aposten per modularitat i seguretat a costa de lat√®ncia.
-   Els modulars permeten cr√©ixer sense reescriure tot el nucli.
-   Els exokernels lliuren el control directe a l‚Äôaplicaci√≥ per m√†xima efici√®ncia.
-   Els hipervisors faciliten la conviv√®ncia d‚Äôecosistemes sencers sobre un mateix hardware.
-   Els unikernels empaqueten aplicaci√≥ i SO per a desplegaments ultralleugers i segurs.
:::

::: {.column width="40%"}
![](https://static.posters.cz/image/750/posters/looney-tunes-thats-all-folks-i295.jpg)
:::
:::::